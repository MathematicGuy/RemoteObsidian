/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Brainframe
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  gitmarks: "gitmarks.md",
  products: "products.md",
  giftideas: "giftideas.md",
  archived: "_archived"
};
function validateUrl(url) {
  const urlref = new URL(url);
  if (!urlref) {
    throw new Error(`invalid URL ${url}`);
  }
  return urlref;
}
var Brainframe = class extends import_obsidian.Plugin {
  async addMarksFile(fname, id, cmdname) {
    this.addCommand({
      id,
      name: cmdname,
      callback: async () => {
        const url = await navigator.clipboard.readText();
        validateUrl(url);
        new import_obsidian.Notice(`Attempting to load ${url}`);
        const folderOrFile = this.app.vault.getAbstractFileByPath(fname);
        if (folderOrFile instanceof import_obsidian.TFile) {
          (0, import_obsidian.request)(url).then((body) => {
            const parser = new DOMParser();
            const parsedDocument = parser.parseFromString(body, "text/html");
            const pageTitle = parsedDocument.title;
            this.app.vault.append(folderOrFile, `- [${pageTitle}](${url})
`);
            new import_obsidian.Notice(`Added ${pageTitle} to ${fname}`);
          }).catch((err) => {
            new import_obsidian.Notice(`Unable to load ${url}: ${err}`);
          });
        } else if (folderOrFile instanceof import_obsidian.TFolder) {
          new import_obsidian.Notice(`Unable to add mark, ${fname} is a folder`);
          throw new Error("invalid URL");
        }
      }
    });
  }
  async ensureArchiveExists() {
    const archive_check = this.app.vault.getAbstractFileByPath(this.settings.archived);
    const exists = archive_check instanceof import_obsidian.TFile || archive_check instanceof import_obsidian.TFolder;
    if (!exists) {
      await this.app.vault.createFolder(this.settings.archived);
    }
    const archive = this.app.vault.getAbstractFileByPath(this.settings.archived);
    if (!(archive instanceof import_obsidian.TFolder)) {
      new import_obsidian.Notice("An error occurred creating your archive folder.");
      throw new Error("Error during archive creation");
    }
  }
  async archiveNote(toArchive) {
    await this.ensureArchiveExists();
    if (toArchive instanceof import_obsidian.TFile) {
      await this.app.vault.rename(toArchive, `${this.settings.archived}/${toArchive == null ? void 0 : toArchive.name}`);
      await this.app.fileManager.processFrontMatter(toArchive, (frontMatter) => {
        if (frontMatter.tags == null) {
          frontMatter.tags = new Array();
        }
        const tag = `#${this.settings.archived}`;
        if (frontMatter.tags.indexOf(tag) == -1) {
          frontMatter.tags.push(tag);
        }
      });
      new import_obsidian.Notice(`${toArchive.name} has been archived.`);
    }
  }
  async onload() {
    await this.loadSettings();
    await this.addMarksFile(this.settings.gitmarks, "add-gitmark", "Add Git bookmark");
    await this.addMarksFile(this.settings.products, "add-productmark", "Add Product bookmark");
    await this.addMarksFile(this.settings.giftideas, "add-giftidea", "Add Gift Idea bookmark");
    this.addCommand({
      id: "archive-note",
      name: "Archive Current Note",
      editorCallback: (editor) => {
        this.archiveNote(this.app.workspace.getActiveFile());
      }
    });
    this.registerEvent(this.app.workspace.on("file-menu", (menu, file) => {
      menu.addItem((item) => {
        item.setTitle("Archive Note").setIcon("document").onClick(async () => {
          await this.archiveNote(file);
        });
      });
    }));
    this.registerEvent(this.app.workspace.on("editor-menu", (menu, editor, view) => {
      menu.addItem((item) => {
        item.setTitle("Archive current note").setIcon("document").onClick(async () => {
          await this.archiveNote(view.file);
        });
      });
    }));
    this.addSettingTab(new BrainframeSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var BrainframeSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Brainframe Settings" });
    new import_obsidian.Setting(containerEl).setName("Gitmarks file:").setDesc("Note for storing repository related bookmarks.").addText((text) => text.setPlaceholder("Enter your gitmarks note name").setValue(this.plugin.settings.gitmarks).onChange(async (value) => {
      this.plugin.settings.gitmarks = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Products file:").setDesc("Note for storing product related bookmarks.").addText((text) => text.setPlaceholder("Enter your products note name").setValue(this.plugin.settings.products).onChange(async (value) => {
      this.plugin.settings.products = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Archived notes folder:").setDesc("Location to store archived notes.").addText((text) => text.setPlaceholder("Enter the name of the archived notes folder").setValue(this.plugin.settings.archived).onChange(async (value) => {
      this.plugin.settings.archived = value;
      await this.plugin.saveSettings();
    }));
  }
};


/* nosourcemap */